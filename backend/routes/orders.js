const express = require('express');
const { body, validationResult } = require('express-validator');
const Order = require('../models/Order');
const Product = require('../models/Product');
const Cart = require('../models/Cart');
const User = require('../models/User');
const { protect, admin } = require('../middleware/auth');

const router = express.Router();

// @desc    Create new order
// @route   POST /api/orders
// @access  Private
router.post('/', protect, [
  body('orderItems')
    .isArray({ min: 1 })
    .withMessage('Order must contain at least one item'),
  body('shippingAddress.fullName')
    .trim()
    .isLength({ min: 1 })
    .withMessage('Full name is required'),
  body('shippingAddress.address')
    .trim()
    .isLength({ min: 1 })
    .withMessage('Address is required'),
  body('shippingAddress.city')
    .trim()
    .isLength({ min: 1 })
    .withMessage('City is required'),
  body('shippingAddress.state')
    .trim()
    .isLength({ min: 1 })
    .withMessage('State is required'),
  body('shippingAddress.zipCode')
    .trim()
    .isLength({ min: 1 })
    .withMessage('Zip code is required'),
  body('shippingAddress.phone')
    .matches(/^[0-9]{10}$/)
    .withMessage('Valid phone number is required'),
  body('paymentMethod')
    .isIn(['card', 'razorpay', 'paypal', 'cod', 'upi'])
    .withMessage('Invalid payment method'),
  body('itemsPrice')
    .isFloat({ min: 0 })
    .withMessage('Items price must be a positive number'),
  body('taxPrice')
    .isFloat({ min: 0 })
    .withMessage('Tax price must be a positive number'),
  body('shippingPrice')
    .isFloat({ min: 0 })
    .withMessage('Shipping price must be a positive number'),
  body('totalPrice')
    .isFloat({ min: 0 })
    .withMessage('Total price must be a positive number')
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const {
      orderItems,
      shippingAddress,
      paymentMethod,
      itemsPrice,
      taxPrice,
      shippingPrice,
      totalPrice,
      discountAmount,
      couponCode,
      orderNumber
    } = req.body;

    console.log('ðŸ“¦ Creating order with pricing details:', {
      itemsPrice: Number(itemsPrice),
      taxPrice: Number(taxPrice),
      shippingPrice: Number(shippingPrice),
      totalPrice: Number(totalPrice),
      discountAmount: Number(discountAmount) || 0,
      couponCode: couponCode || null,
      calculatedTotal: Number(itemsPrice) + Number(taxPrice) + Number(shippingPrice),
      expectedAfterDiscount: Number(itemsPrice) + Number(taxPrice) + Number(shippingPrice) - (Number(discountAmount) || 0)
    });

    // Validate order items and check stock
    for (let item of orderItems) {
      const product = await Product.findById(item.product);
      if (!product || !product.isActive) {
        return res.status(404).json({
          status: 'error',
          message: `Product ${item.name} not found`
        });
      }

      if (product.stock < item.quantity) {
        return res.status(400).json({
          status: 'error',
          message: `Insufficient stock for ${product.name}. Only ${product.stock} available.`
        });
      }
    }

    // Create order (orderNumber will be auto-generated by pre-save middleware)
    const order = await Order.create({
      user: req.user._id,
      orderNumber: orderNumber, // Let the model generate if not provided
      orderItems: orderItems.map(item => ({
        ...item,
        product: item.product,
        sku: item.sku || `SKU-${item.product || Math.random().toString(36).substr(2, 8).toUpperCase()}`
      })),
      shippingAddress,
      paymentMethod,
      paymentResult: {
        status: paymentMethod === 'cod' ? 'PENDING' : 'COMPLETED',
        transactionId: `${paymentMethod.toUpperCase()}_${Date.now()}`,
        amount: totalPrice
      },
      itemsPrice: Number(itemsPrice),
      taxPrice: Number(taxPrice),
      shippingPrice: Number(shippingPrice),
      totalPrice: Number(totalPrice),
      discountAmount: Number(discountAmount) || 0,
      couponCode: couponCode || null,
      isPaid: paymentMethod !== 'cod',
      paidAt: paymentMethod !== 'cod' ? new Date() : null,
      orderStatus: 'confirmed'
    });

    // Update product stock and sales count
    for (let item of orderItems) {
      await Product.findByIdAndUpdate(item.product, {
        $inc: {
          stock: -item.quantity,
          salesCount: item.quantity
        }
      });
    }

    // Handle coupon usage tracking for order completion
    if (couponCode) {
      try {
        console.log(`ðŸŽ« Processing coupon ${couponCode} for order completion`);
        const Coupon = require('../models/Coupon');
        const couponUpdate = await Coupon.findOneAndUpdate(
          { code: couponCode.toUpperCase() },
          {
            $inc: { usageCount: 1 },
            $push: {
              usedBy: {
                user: req.user._id,
                usedAt: new Date()
              }
            }
          },
          { new: true }
        );
        
        if (couponUpdate) {
          console.log(`âœ… Coupon ${couponCode} usage incremented to ${couponUpdate.usageCount}/${couponUpdate.usageLimit}`);
        } else {
          console.log(`âŒ Coupon ${couponCode} not found for usage increment`);
        }
      } catch (couponError) {
        console.error('âŒ Error updating coupon usage for order:', couponError);
        // Don't fail the order if coupon update fails
      }
    }

    // Clear user's cart (but note that cart coupon usage was already tracked)
    console.log(`ðŸ›’ Clearing cart for user ${req.user._id}`);
    const cart = await Cart.findOne({ user: req.user._id });
    if (cart && cart.appliedCoupon && cart.appliedCoupon.code) {
      console.log(`ðŸŽ« Cart has coupon: ${cart.appliedCoupon.code}, Order coupon: ${couponCode || 'none'}`);
      // If the cart has a different coupon than the order, decrement the cart coupon
      if (cart.appliedCoupon.code.toUpperCase() !== (couponCode || '').toUpperCase()) {
        try {
          console.log(`ðŸ”„ Different coupon in cart, decrementing ${cart.appliedCoupon.code} usage`);
          const Coupon = require('../models/Coupon');
          const cartCouponUpdate = await Coupon.findOneAndUpdate(
            { code: cart.appliedCoupon.code },
            {
              $inc: { usageCount: -1 },
              $pull: { usedBy: { user: req.user._id } }
            },
            { new: true }
          );
          if (cartCouponUpdate) {
            console.log(`âœ… Cart coupon ${cart.appliedCoupon.code} usage decremented to ${cartCouponUpdate.usageCount}/${cartCouponUpdate.usageLimit}`);
          }
        } catch (couponError) {
          console.error('âŒ Error decrementing cart coupon usage:', couponError);
        }
      } else {
        console.log(`âœ… Same coupon used in cart and order: ${couponCode}`);
      }
      cart.clearCart();
      await cart.save();
      console.log(`ðŸ›’ Cart cleared and saved`);
    } else if (cart) {
      console.log(`ðŸ›’ Cart found but no coupon applied`);
      cart.clearCart();
      await cart.save();
    } else {
      console.log(`ðŸ›’ No cart found for user`);
    }

    // Populate order for response
    await order.populate('user', 'name email');

    console.log('ðŸŽ¯ Order created successfully:', {
      orderId: order._id,
      orderNumber: order.orderNumber,
      userId: order.user._id,
      couponCode: order.couponCode,
      discountAmount: order.discountAmount
    });

    res.status(201).json({
      status: 'success',
      message: 'Order created successfully',
      data: {
        order
      }
    });
  } catch (error) {
    console.error('Create order error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error while creating order'
    });
  }
});

// @desc    Get user's orders
// @route   GET /api/orders/my-orders
// @access  Private
router.get('/my-orders', protect, async (req, res) => {
  try {
    const orders = await Order.find({ user: req.user._id })
      .sort({ createdAt: -1 })
      .populate('orderItems.product', 'name image images galleryImages');

    res.json({
      status: 'success',
      data: {
        orders
      }
    });
  } catch (error) {
    console.error('Get user orders error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error while fetching orders'
    });
  }
});

// @desc    Get order by ID
// @route   GET /api/orders/:id
// @access  Private
router.get('/:id', protect, async (req, res) => {
  try {
    const order = await Order.findById(req.params.id)
      .populate('user', 'name email')
      .populate('orderItems.product', 'name image images galleryImages price');

    if (!order) {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }

    // Check if user owns the order or is admin
    if (order.user._id.toString() !== req.user._id.toString() && req.user.role !== 'admin') {
      return res.status(403).json({
        status: 'error',
        message: 'Access denied. You can only view your own orders.'
      });
    }

    res.json({
      status: 'success',
      data: {
        order
      }
    });
  } catch (error) {
    console.error('Get order error:', error);
    if (error.name === 'CastError') {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }
    res.status(500).json({
      status: 'error',
      message: 'Server error while fetching order'
    });
  }
});

// @desc    Update order payment status
// @route   PUT /api/orders/:id/pay
// @access  Private
router.put('/:id/pay', protect, [
  body('paymentResult.id').notEmpty().withMessage('Payment ID is required'),
  body('paymentResult.status').notEmpty().withMessage('Payment status is required')
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }

    // Check if user owns the order
    if (order.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        status: 'error',
        message: 'Access denied. You can only update your own orders.'
      });
    }

    if (order.isPaid) {
      return res.status(400).json({
        status: 'error',
        message: 'Order is already paid'
      });
    }

    // Update payment information
    order.isPaid = true;
    order.paidAt = Date.now();
    order.paymentResult = req.body.paymentResult;
    order.orderStatus = 'confirmed';

    // Add note
    order.notes.push({
      message: 'Payment completed successfully',
      addedBy: 'system'
    });

    await order.save();

    res.json({
      status: 'success',
      message: 'Order payment updated successfully',
      data: {
        order
      }
    });
  } catch (error) {
    console.error('Update payment error:', error);
    if (error.name === 'CastError') {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }
    res.status(500).json({
      status: 'error',
      message: 'Server error while updating payment'
    });
  }
});

// @desc    Cancel order
// @route   PUT /api/orders/:id/cancel
// @access  Private
router.put('/:id/cancel', protect, [
  body('reason')
    .trim()
    .isLength({ min: 1, max: 200 })
    .withMessage('Cancellation reason is required and must be less than 200 characters')
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }

    // Check if user owns the order
    if (order.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        status: 'error',
        message: 'Access denied. You can only cancel your own orders.'
      });
    }

    // Check if order can be cancelled
    if (['delivered', 'cancelled', 'returned'].includes(order.orderStatus)) {
      return res.status(400).json({
        status: 'error',
        message: `Order cannot be cancelled. Current status: ${order.orderStatus}`
      });
    }

    // Update order status
    order.orderStatus = 'cancelled';
    order.cancelReason = req.body.reason;

    // Add note
    order.notes.push({
      message: `Order cancelled by customer. Reason: ${req.body.reason}`,
      addedBy: req.user.name
    });

    // Restore product stock
    for (let item of order.orderItems) {
      await Product.findByIdAndUpdate(item.product, {
        $inc: {
          stock: item.quantity,
          salesCount: -item.quantity
        }
      });
    }

    await order.save();

    res.json({
      status: 'success',
      message: 'Order cancelled successfully',
      data: {
        order
      }
    });
  } catch (error) {
    console.error('Cancel order error:', error);
    if (error.name === 'CastError') {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }
    res.status(500).json({
      status: 'error',
      message: 'Server error while cancelling order'
    });
  }
});

// @desc    Get all orders (Admin only)
// @route   GET /api/orders
// @access  Private/Admin
router.get('/', protect, admin, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    // Build filter
    let filter = {};
    if (req.query.status) {
      filter.orderStatus = req.query.status;
    }
    if (req.query.isPaid !== undefined) {
      filter.isPaid = req.query.isPaid === 'true';
    }

    const orders = await Order.find(filter)
      .populate('user', 'name email')
      .populate('orderItems.product', 'name image images galleryImages')
      .sort({ createdAt: -1 })
      .limit(limit)
      .skip(skip);

    const totalOrders = await Order.countDocuments(filter);
    const totalPages = Math.ceil(totalOrders / limit);

    // Get order statistics
    const stats = await Order.aggregate([
      {
        $group: {
          _id: null,
          totalOrders: { $sum: 1 },
          totalRevenue: { $sum: '$totalPrice' },
          pendingOrders: {
            $sum: { $cond: [{ $eq: ['$orderStatus', 'pending'] }, 1, 0] }
          },
          completedOrders: {
            $sum: { $cond: [{ $eq: ['$orderStatus', 'delivered'] }, 1, 0] }
          }
        }
      }
    ]);

    res.json({
      status: 'success',
      data: {
        orders,
        pagination: {
          currentPage: page,
          totalPages,
          totalOrders,
          hasNextPage: page < totalPages,
          hasPrevPage: page > 1
        },
        stats: stats[0] || {
          totalOrders: 0,
          totalRevenue: 0,
          pendingOrders: 0,
          completedOrders: 0
        }
      }
    });
  } catch (error) {
    console.error('Get all orders error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error while fetching orders'
    });
  }
});

// @desc    Update order status (Admin only)
// @route   PUT /api/orders/:id/status
// @access  Private/Admin
router.put('/:id/status', protect, admin, [
  body('status')
    .isIn(['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'returned'])
    .withMessage('Invalid order status'),
  body('note')
    .optional()
    .trim()
    .isLength({ max: 200 })
    .withMessage('Note must be less than 200 characters')
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { status, note, trackingNumber, estimatedDelivery } = req.body;

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }

    // Update order
    order.updateStatus(status, note);

    if (trackingNumber) {
      order.trackingNumber = trackingNumber;
    }

    if (estimatedDelivery) {
      order.estimatedDelivery = new Date(estimatedDelivery);
    }

    // Add admin note
    if (note) {
      order.notes.push({
        message: note,
        addedBy: req.user.name
      });
    }

    await order.save();

    res.json({
      status: 'success',
      message: 'Order status updated successfully',
      data: {
        order
      }
    });
  } catch (error) {
    console.error('Update order status error:', error);
    if (error.name === 'CastError') {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }
    res.status(500).json({
      status: 'error',
      message: 'Server error while updating order status'
    });
  }
});

// @desc    Delete order
// @route   DELETE /api/orders/:id
// @access  Private
router.delete('/:id', protect, async (req, res) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }

    // Check if user owns the order or is admin
    if (order.user.toString() !== req.user._id.toString() && req.user.role !== 'admin') {
      return res.status(403).json({
        status: 'error',
        message: 'Not authorized to delete this order'
      });
    }

    // Only allow deletion of cancelled or delivered orders
    if (order.orderStatus !== 'cancelled' && order.orderStatus !== 'delivered') {
      return res.status(400).json({
        status: 'error',
        message: 'Can only delete cancelled or delivered orders'
      });
    }

    await Order.findByIdAndDelete(req.params.id);

    res.json({
      status: 'success',
      message: 'Order deleted successfully'
    });
  } catch (error) {
    console.error('Delete order error:', error);
    if (error.name === 'CastError') {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }
    res.status(500).json({
      status: 'error',
      message: 'Server error while deleting order'
    });
  }
});

// @desc    Generate and download invoice for order
// @route   GET /api/orders/:id/invoice
// @access  Private
router.get('/:id/invoice', protect, async (req, res) => {
  try {
    const order = await Order.findById(req.params.id)
      .populate('user', 'name email')
      .populate('orderItems.product', 'name price');

    if (!order) {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }

    // Check if user owns the order or is admin
    if (order.user._id.toString() !== req.user._id.toString() && req.user.role !== 'admin') {
      return res.status(403).json({
        status: 'error',
        message: 'Not authorized to access this invoice'
      });
    }

    // Create Clean Invoice PDF with Fixed Positioning
    const PDFDocument = require('pdfkit');
    
    const doc = new PDFDocument({ 
      margin: 60,
      size: 'A4'
    });

    // Set response headers
    const invoiceNumber = order.orderNumber || `SA-2025-${order._id.toString().slice(-6).toUpperCase()}`;
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename=invoice-${invoiceNumber}.pdf`);

    doc.pipe(res);

    // Constants
    const PAGE_WIDTH = 535; // A4 width minus margins
    const LEFT_X = 60;
    const RIGHT_X = 320;
    let currentY = 60;

    // Helper function to add space
    const addSpace = (space) => {
      currentY += space;
    };

    // Company Header - Centered
    doc.fontSize(28)
       .fillColor('#1a365d')
       .text('SonicMart', LEFT_X, currentY, { 
         align: 'center', 
         width: PAGE_WIDTH 
       });
    addSpace(35);

    doc.fontSize(14)
       .fillColor('#4a5568')
       .text('Sounds Accessories and Components', LEFT_X, currentY, { 
         align: 'center', 
         width: PAGE_WIDTH 
       });
    addSpace(20);

    doc.fontSize(11)
       .text('Email: info@sonicmart.com | Phone: +91 9876543210', LEFT_X, currentY, { 
         align: 'center', 
         width: PAGE_WIDTH 
       });
    addSpace(35);

    // Header Line
    doc.moveTo(LEFT_X, currentY)
       .lineTo(LEFT_X + PAGE_WIDTH, currentY)
       .strokeColor('#cccccc')
       .stroke();
    addSpace(35);

    // Invoice Title
    doc.fontSize(24)
       .fillColor('#1a365d')
       .text('INVOICE', LEFT_X, currentY);
    addSpace(45);

    // Invoice Details Section - Two Columns with Fixed Positioning
    const detailsY = currentY;

    // LEFT COLUMN - Invoice Details
    doc.fontSize(12)
       .fillColor('#2d3748')
       .text(`Invoice #: ${invoiceNumber}`, LEFT_X, detailsY);

    doc.fontSize(11)
       .text(`Order Date: ${new Date(order.createdAt).toLocaleDateString('en-IN')}`, LEFT_X, detailsY + 20);

    doc.text(`Status: ${order.orderStatus.toUpperCase()}`, LEFT_X, detailsY + 40);

    // RIGHT COLUMN - Customer Details with Fixed Y Positions
    doc.fontSize(12)
       .fillColor('#2d3748')
       .text('Bill To:', RIGHT_X, detailsY);

    doc.fontSize(11)
       .fillColor('#1a365d')
       .text(order.user.name, RIGHT_X, detailsY + 20);

    doc.fontSize(10)
       .fillColor('#4a5568')
       .text(order.user.email, RIGHT_X, detailsY + 35);

    // Shipping Address - Each line on separate Y position
    if (order.shippingAddress) {
      let addressY = detailsY + 55;
      
      if (order.shippingAddress.address) {
        // Split long address into multiple lines if needed
        const address = order.shippingAddress.address;
        if (address.length > 30) {
          const words = address.split(' ');
          let line1 = '';
          let line2 = '';
          
          for (let word of words) {
            if ((line1 + word).length <= 30) {
              line1 += (line1 ? ' ' : '') + word;
            } else {
              line2 += (line2 ? ' ' : '') + word;
            }
          }
          
          doc.text(line1, RIGHT_X, addressY);
          addressY += 15;
          if (line2) {
            doc.text(line2, RIGHT_X, addressY);
            addressY += 15;
          }
        } else {
          doc.text(address, RIGHT_X, addressY);
          addressY += 15;
        }
      }
      
      if (order.shippingAddress.city && order.shippingAddress.state) {
        doc.text(`${order.shippingAddress.city}, ${order.shippingAddress.state}`, RIGHT_X, addressY);
        addressY += 15;
      }
      
      if (order.shippingAddress.zipCode) {
        doc.text(order.shippingAddress.zipCode, RIGHT_X, addressY);
        addressY += 15;
      }
      
      if (order.shippingAddress.country) {
        doc.text(order.shippingAddress.country, RIGHT_X, addressY);
      }
    }

    // Move to next section - ensure enough space
    currentY = Math.max(detailsY + 120, currentY);
    addSpace(40);

    // Items Section Header
    doc.fontSize(14)
       .fillColor('#2d3748')
       .text('Order Items', LEFT_X, currentY);
    addSpace(25);

    // Table Header Background
    doc.rect(LEFT_X, currentY, PAGE_WIDTH, 25)
       .fillColor('#f8f8f8')
       .fill();

    // Table Headers with proper spacing - using calculated positions
    const itemColX = LEFT_X + 10;
    const qtyColX = LEFT_X + 280;
    const priceColX = LEFT_X + 340;
    const totalColX = LEFT_X + 420;

    doc.fontSize(11)
       .fillColor('#2d3748')
       .text('Item', itemColX, currentY + 8)
       .text('Qty', qtyColX, currentY + 8)
       .text('Price', priceColX, currentY + 8)
       .text('Total', totalColX, currentY + 8);
    
    addSpace(30);

    // Table Border
    doc.moveTo(LEFT_X, currentY)
       .lineTo(LEFT_X + PAGE_WIDTH, currentY)
       .strokeColor('#dddddd')
       .stroke();
    addSpace(15);

    // Items - Each item with proper column alignment
    doc.fontSize(10)
       .fillColor('#4a5568');

    order.orderItems.forEach((item, index) => {
      // Alternate row background
      if (index % 2 === 0) {
        doc.rect(LEFT_X, currentY - 5, PAGE_WIDTH, 20)
           .fillColor('#fafafa')
           .fill();
      }
      
      const itemName = item.product?.name || item.name || 'Product';
      // Truncate name to fit in column (about 30 chars for item column)
      const displayName = itemName.length > 30 ? itemName.substring(0, 27) + '...' : itemName;
      
      // Use the same column positions as headers
      doc.fillColor('#4a5568')
         .text(displayName, itemColX, currentY);
      
      doc.text(item.quantity.toString(), qtyColX, currentY);
      doc.text(`â‚¹${item.price?.toLocaleString('en-IN')}`, priceColX, currentY);
      doc.text(`â‚¹${(item.quantity * item.price)?.toLocaleString('en-IN')}`, totalColX, currentY);
      
      addSpace(20);
    });

    addSpace(20);

    // Totals Section - Right aligned with enough space
    const totalsStartX = LEFT_X + 280;
    const totalsValueX = LEFT_X + 420;
    
    doc.moveTo(totalsStartX, currentY)
       .lineTo(LEFT_X + PAGE_WIDTH, currentY)
       .strokeColor('#cccccc')
       .stroke();
    addSpace(15);

    doc.fontSize(11)
       .fillColor('#4a5568');

    // Subtotal
    doc.text('Subtotal:', totalsStartX, currentY);
    doc.text(`â‚¹${(order.itemsPrice || 0).toLocaleString('en-IN')}`, totalsValueX, currentY);
    addSpace(18);

    // Shipping
    doc.text('Shipping:', totalsStartX, currentY);
    doc.text(`â‚¹${(order.shippingPrice || 0).toLocaleString('en-IN')}`, totalsValueX, currentY);
    addSpace(18);

    // Coupon Discount (if applied)
    let actualDiscountAmount = order.discountAmount || 0;
    
    // If discount amount is not stored but we have a coupon code and the total suggests a discount was applied
    if (!actualDiscountAmount && order.couponCode) {
      // Calculate discount from the difference between items + shipping + tax vs total
      const calculatedTotal = (order.itemsPrice || 0) + (order.shippingPrice || 0) + (order.taxPrice || 0);
      const actualTotal = order.totalPrice || 0;
      actualDiscountAmount = Math.max(0, calculatedTotal - actualTotal);
    }
    
    if (actualDiscountAmount > 0) {
      doc.fillColor('#dc3545'); // Red color for discount
      doc.text('Coupon Discount:', totalsStartX, currentY);
      doc.text(`-â‚¹${actualDiscountAmount.toLocaleString('en-IN')}`, totalsValueX, currentY);
      
      // Add coupon code if available
      if (order.couponCode) {
        doc.fontSize(9)
           .fillColor('#6c757d')
           .text(`(${order.couponCode})`, totalsValueX + 80, currentY);
        doc.fontSize(11)
           .fillColor('#4a5568'); // Reset to normal color
      }
      addSpace(18);
    }

    // Tax (if any)
    if (order.taxPrice && order.taxPrice > 0) {
      doc.text('Tax:', totalsStartX, currentY);
      doc.text(`â‚¹${order.taxPrice.toLocaleString('en-IN')}`, totalsValueX, currentY);
      addSpace(18);
    }

    // Total line
    doc.moveTo(totalsStartX, currentY)
       .lineTo(LEFT_X + PAGE_WIDTH, currentY)
       .strokeColor('#2d3748')
       .lineWidth(2)
       .stroke();
    addSpace(15);

    // Final Total
    doc.fontSize(13)
       .fillColor('#1a365d')
       .text('Total:', totalsStartX, currentY);
    doc.text(`â‚¹${(order.totalPrice || 0).toLocaleString('en-IN')}`, totalsValueX, currentY);
    addSpace(40);

    // Payment Information
    doc.fontSize(12)
       .fillColor('#2d3748')
       .text('Payment Information', LEFT_X, currentY);
    addSpace(20);

    doc.fontSize(11)
       .fillColor('#4a5568')
       .text(`Payment Method: ${(order.paymentMethod || 'COD').toUpperCase()}`, LEFT_X, currentY);
    addSpace(15);

    if (order.paymentResult && order.paymentResult.id) {
      doc.text(`Transaction ID: ${order.paymentResult.id}`, LEFT_X, currentY);
      addSpace(15);
    }

    const paymentStatus = order.isPaid ? 'PAID' : 'PENDING';
    doc.text(`Payment Status: ${paymentStatus}`, LEFT_X, currentY);
    addSpace(40);

    // Footer
    doc.rect(LEFT_X, currentY, PAGE_WIDTH, 50)
       .fillColor('#f8f8f8')
       .fill();

    doc.fontSize(12)
       .fillColor('#4a5568')
       .text('Thank you for your business!', LEFT_X + 15, currentY + 15);
    
    doc.fontSize(10)
       .text('For any queries, contact us at support@sonicmart.com', LEFT_X + 15, currentY + 32);

    doc.end();

  } catch (error) {
    console.error('Invoice generation error:', error);
    
    if (error.name === 'CastError') {
      return res.status(404).json({
        status: 'error',
        message: 'Order not found'
      });
    }
    
    res.status(500).json({
      status: 'error',
      message: 'Failed to generate invoice'
    });
  }
});

// @desc    Test order number generation
// @route   GET /api/orders/test/order-number
// @access  Public (for testing only)
router.get('/test/order-number', async (req, res) => {
  try {
    // Import the generateOrderNumber function from Order model
    const mongoose = require('mongoose');
    
    // Simulate the order number generation process
    const currentYear = new Date().getFullYear();
    
    // Use atomic findOneAndUpdate to ensure unique sequential numbers
    const lastOrder = await Order.findOne(
      { orderNumber: { $regex: `^SA-${currentYear}-` } },
      { orderNumber: 1 }
    ).sort({ orderNumber: -1 });

    let sequentialNumber = 1;
    if (lastOrder && lastOrder.orderNumber) {
      // Extract the number from the last order number (e.g., "SA-2025-000016" -> 16)
      const lastNumber = parseInt(lastOrder.orderNumber.split('-')[2]);
      sequentialNumber = lastNumber + 1;
    }

    // Generate unique number with timestamp fallback to prevent duplicates
    const timestamp = Date.now().toString().slice(-6); // Last 6 digits of timestamp
    const finalNumber = String(sequentialNumber).padStart(6, '0');
    
    // Check if this number already exists, if so, use timestamp-based number
    const existingOrder = await Order.findOne({ orderNumber: `SA-${currentYear}-${finalNumber}` });
    
    let nextOrderNumber;
    if (existingOrder) {
      nextOrderNumber = `SA-${currentYear}-${timestamp}`;
    } else {
      nextOrderNumber = `SA-${currentYear}-${finalNumber}`;
    }
    
    res.json({
      status: 'success',
      data: {
        nextOrderNumber,
        lastOrderNumber: lastOrder?.orderNumber,
        sequentialNumber,
        hasConflict: !!existingOrder,
        totalOrders: await Order.countDocuments()
      }
    });
  } catch (error) {
    console.error('Order number test error:', error);
    res.status(500).json({
      status: 'error',
      message: error.message
    });
  }
});

module.exports = router;
